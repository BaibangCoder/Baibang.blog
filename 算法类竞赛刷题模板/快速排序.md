# 排序

## STL中的快排模板容器————sort

在C++ STL中，sort是一个非常常用的容器，它用于对数组或向量等容器中的元素进行排序。sort容器是一个模板类，定义在`<algorithm>`头文件中。它可以接受一个迭代器范围，用于指定需要排序的元素的位置范围。

sort容器提供了多种排序算法，包括快速排序、归并排序、堆排序等等。STL会根据数据规模和数据类型的不同自动选择最优的排序算法。默认情况下，sort容器采用快速排序算法。**如果需要使用其他排序算法，可以通过传递第三个参数来指定**。

默认情况下，sort容器采用快速排序算法。在平均情况下，快速排序的时间复杂度为O(nlogn)，其中n是待排序元素的数量。在最坏情况下，快速排序的时间复杂度为O(n^2)，这种情况发生在数组已经有序的情况下。

如果数据集合较小，sort容器也可以采用插入排序算法，这种情况下时间复杂度为O(n^2)。

此外，sort容器还可以采用归并排序算法和堆排序算法。归并排序的时间复杂度为O(nlogn)，而堆排序的时间复杂度为O(nlogn)。与快速排序相比，归并排序和堆排序在最坏情况下的时间复杂度更稳定，不会像快速排序那样出现O(n^2)的情况。

```c++
int q[10];
sort(q,q+10);//也可以自带第三个参数，自定义排序类型//默认从小到大
```

## 快速排序

快排的主要思想是分治，

```c++
//分治算法通常包括三个步骤：
//1.分解原问题：将原问题分解成若干个相互独立的子问题，每个子问题的结构与原问题相同。
//2.解决子问题：递归地解决每个子问题，直到子问题可以直接求解为止。
//3.合并子问题的解：将子问题的解合并成原问题的解。
```

### 手写模板

快排的思想是利用双指针，一个指向开头，一个指向末尾，都向中间移动，通过与指定的x值比较来进行排序

```c++
//具体来说，快速排序的实现步骤如下：
//1.选取一个关键元素作为枢轴，例如选取待排序数组的中间元素。
//2.将待排序数组分成两个子数组，一个子数组中的所有元素都小于枢轴，另一个子数组中的所有元素都大于或等于枢轴。可以使用两个指针从	数组两端开始遍历，分别找到第一个大于等于枢轴和小于枢轴的元素，然后交换它们的位置，直到两个指针相遇。
//3.对子数组进行递归排序，直到子数组的长度为 1 或 0。
//4.不需要合并，排序完成。
```

这里给出手写模板代码

```c++
#include <iostream>
#include <vector>
using namespace std;
void quickSort(vector<int>& nums, int left, int right) {
    if (left >= right) {
        return;  // 子数组长度为 1 或 0，不需要排序
    }
    int i = left, j = right, pivot = nums[(left + right) / 2]; // 选取枢轴
    while (i <= j) {
        while (nums[i] < pivot) {
            i++;  // 找到第一个大于等于枢轴的元素
        }
        while (nums[j] > pivot) {
            j--;  // 找到第一个小于枢轴的元素
        }
        if (i <= j) {
            swap(nums[i], nums[j]);  // 交换这两个元素
            i++;
            j--;
        }
    }
    quickSort(nums, left, j);  // 对左子数组递归排序
    quickSort(nums, i, right);  // 对右子数组递归排序
}
//////////////////////////////////////////////////////////////////////////////////////////
int main() {
    vector<int> nums = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};
    quickSort(nums, 0, nums.size() - 1);
    for (int num : nums) {
        cout << num << " ";
    }
    cout << endl;
    return 0;
}
```

### 基于快速排序——快速选择排序

快速选择排序（Quickselect）是一种基于快速排序算法的选择算法，它的**主要目的是从一个未排序的数组中选择第 k 小或第 k 大的元素。**

快速选择排序的基本思路是选取一个基准元素，然后将数组中比它小的元素放到它的左边，比它大的元素放到它的右边。这样，基准元素就处于数组中的正确位置。如果基准元素的下标恰好为 k-1，那么它就是第 k 小的元素；如果它的下标小于 k-1，那么第 k 小的元素就在它的右边；如果它的下标大于 k-1，那么第 k 小的元素就在它的左边。

快速选择排序的时间复杂度为 O(n)，其中 n 是待选择的数组的长度。它比传统的排序算法更加高效，因为它不需要对整个数组进行排序，而只需要找到第 k 小的元素即可。

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=100010;
int p[N];
int  quick_sort(int p[], int l, int r,int k){
    if(l>=r) return p[l];
    
    int i= l-1, j= r+1, x= p[ l + r >> 1];
    while(i<j){
        do i++; while(p[i]<x);
        do j--; while(p[j]>x);
        if(i<j)swap(p[i],p[j]);
    }
    if(j - l + 1 >= k)return quick_sort(p,l,j,k);
    else return quick_sort(p,j+1,r,k - (j - l + 1));
}
int main(){
    int n,k;
    cin >> n >> k;
    for(int i=0;i<n;i++)cin >> p[i];
    cout<<quick_sort(p,0,n-1,k)<<endl;
    return 0;
}
```

算法过程：

下面是使用快速选择排序算法查找数组中第k小元素的过程：

1. 选择pivot值：首先，我们需要选择一个pivot值作为比较的标准。通常情况下，我们可以选择数组中的中间元素作为pivot值。
2. 划分数组：将数组划分为小于pivot值的部分和大于pivot值的部分，其中pivot值被放置在了正确的位置上。这个过程可以通过partition函数来实现。partition函数将数组分为两个部分，左边部分中的元素都小于pivot值，右边部分中的元素都大于pivot值。
3. 比较k和pivot位置：将pivot位置与k进行比较，如果k小于pivot位置，说明第k小元素在pivot的左侧，我们就对左侧部分的数组递归地应用快速选择排序；如果k大于pivot位置，说明第k小元素在pivot的右侧，我们就对右侧部分的数组递归地应用快速选择排序；如果k等于pivot位置，说明第k小元素就是pivot位置上的元素，直接返回即可。
4. 重复上述过程：重复上述过程，直到找到第k小元素。

总体上，快速选择排序算法的核心思想和快速排序算法类似，都是通过分治的思想来排序。但快速选择排序不同的是，它只需要对部分数组进行排序，可以减少算法的时间复杂度。

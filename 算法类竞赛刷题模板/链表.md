## 约瑟夫问题

这是个经典的链表题

约瑟夫问题

n个人围成一圈，从第一个人开始报数,数到m的人出列，再由下一个人重新从1开始报数，

数到m的人再出圈，依次类推，直到所有的人都出圈，请输出依次出圈人的编号。

**注意：本题和《深入浅出-基础篇》上例题的表述稍有不同。书上表述是给出淘汰n-1名小朋友，而该题是全部出圈。

输入格式

输入两个整数n,m。

输出格式

输出一行n个整数，按顺序输出每个出圈人的编号。



样例输入

10 3

样例输出

3 6 9 2 7 1 8 5 10 4

```c++
#include<bits/stdc++.h>/////动态链表做法，使用C++的new动态分配内存
using namespace std;
struct node{
    int data;
    node * next;//单向链表；
};
int main(){
    int n,m; cin >> n >> m;
    node *head,*p,*now,*prev;///先定义需要用到的指针
    head = new node; head ->data = 1;head->next=NULL;
    now = head;//////////////head指向链表的首元素
    for(int i=2;i<=n;i++){///p用来添加新的元素，now用来表示当前链表的末尾元素
        p = new node;
        p->data=i;
        p->next=NULL;
        now->next=p;
        now = p;
    }
    now->next=head;///构建循环链表
    now = head ; prev = head;
    while((n--)>1){
        for(int i=1;i<m;i++){
            prev = now;
            now=now->next;
        }
        cout<<now->data<<' ';
        prev->next = now->next;
        delete now;
        now = prev->next;
    }
    cout<<now->data;
    delete now;
    return 0;
}
```

### 静态链表做法，竞赛中多使用静态链表，可以提高AC效率

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=105;
struct node{
    int data,nextid;
}nodes[N];
int main(){
    int n,m; cin >> n >> m;
    nodes[0].nextid = 1;///舍弃第0个元素，使用要有这一步；
    for(int i=1;i<=n;i++){ nodes[i].data=i;nodes[i].nextid=i+1;}//初始化一个循环链表
    nodes[n].nextid=1;////构建循环
    //////下面开始遍历，使用两个遍历记录位置
    int now = 1,prev = 1;
    while((n--)>1){
        for(int i=1;i<m;i++){
            prev = now;
            now=nodes[now].nextid;
        }
        cout<<now<<' ';
        nodes[prev].nextid=nodes[now].nextid;
        now=nodes[now].nextid;
    }
    cout<<now;
    return 0;
}
```

### 用结构体数组实现双向静态链表

```c++
#include<bits/stdc++.h>
using namespace std;
const int LL = 1e3+10;
struct nods{
    int data;///表示数值
    int next;///下一个////要构建循环链表
    int prev;///上一个
}nodes[LL];
int main(){
    int n,m; cin >> n >> m;
    nodes[0].next=1;///舍弃第0个元素空间
    for(int i = 1;i<=n;i++){
        nodes[i].data = i;
        nodes[i].prev =i-1;
        nodes[i].next = i+1;
    }
    nodes[n].next = 1;
    nodes[1].prev = n;
    int now = 1;//做一个标记，准备开始遍历查找
    while((n--)>1){
        for(int i=1;i<m;i++){ now = nodes[now].next;}
        cout<<nodes[now].data<< ' ';
        int p = nodes[now].prev,n = nodes[now].next;
        nodes[p].next = n;
        nodes[n].prev = p;
        now = n;
    }
    cout << nodes[now].data;
    return 0;
}
```

**还可以用一维数组实现单向的静态链表，具体代码不写了，基本思想一致，一维数组实现的思想就是用下标表示数据的值，数组的元素表示下一个节点例：s[i]的i表示数据的值，s[i]的值为i元素的下一个元素**


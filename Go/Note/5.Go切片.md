基于这些文字总结

- [Go 切片：用法和本质 - Go 语言博客 (go-zh.org)](https://blog.go-zh.org/go-slices-usage-and-internals)
- [builtin - Go 编程语言 (go-zh.org)](https://go-zh.org/pkg/builtin/#append)
- 

# 数组

Go的切片是在数组之上的抽象数据类型，因此在了解切片之前必须要先理解数组。

数组定义了**长度**和**元素类型**。数组的长度是固定的的， 长度是数组类型的一部分。

数组可以以常规的索引方式访问。不需要显式的初始化；数组的零值是可以直接使用的，数组元素会自动初始化为其对应类型的零值；**在内存中，数组的地址是连续的。**

Go的数组是值语义。一个数组变量表示整个数组，==它不是指向第一个元素的指针==（不像 C 语言的数组）。 当一个数组变量被赋值或者被传递的时候，实际上会复制整个数组。

>为了避免复制数组，你可以传递一个指向数组的指针，但是数组指针并不是数组。可以将数组看作一个特殊的struct，结构的字段名对应数组的索引，同时成员的数目固定.

```Go
b := [2]string{"penn", "Teller"}
c := []string{"peen", "Teller"}
// 这两种写法是一样的。编译器可以自动统计数组字面值中的元素
```



# 切片

引入切片，是因为，**数组不够灵活**。因此，数组使用的不多，切片基于数组构建，提供了更强的功能和便利。

```go
[]T // T是切片元素的类型。
// 和数组不同，切片没有给固定的长度
```

创建切片是不能指定元素的个数，其他和数组一样。

切片还可以使用内置的`make`函数构建，函数签名为：

```go
func make([]Type, len, cap) []Type
```

make接受三个参数，一个类型，一个长度，一个容量（可选）。调用make时内部会分配一个数组，然后返回数组对应的切片。

> 当容量参数被忽略时，它默认为指定的长度。
>
> 可以使用内置函数`len()`和`cap(s)`来获得切片的长度和容量信息

切片的零值为nil。为0；

如果我们对一个切片进行切片（取出其中的连续的几个数），这个操作并不复制切片指向的元素，它会创建一个新的切片并复用原来切片的底层数组。这是得切片操作和数组索引一样高效。因此，==通过一个新切片去修改元素，会影响到原始切片的对应元素。==

```go
d := []byte{'r', 'o', 'a', 'd'}
e := d[2:]
// e == []byte{'a', 'd'}
e[1] = 'm'
// e == []byte{'a', 'm'}
// d == []byte{'r', 'o', 'a', 'm'}
```

前面使用make创建切片时，可以创建一个长度小于容量的切片，我们可以增长切片的长度为它的容量。

```go
s = s[:cap(s)]
```

> 切片增长不能超出其容量。增长超出切片容量将会导致运行时异常，就像切片或数组的索引超 出范围引起异常一样。同样，不能使用小于零的索引去访问切片之前的元素。

## 切片的生长

**copy and append 函数**

上面的方法只能增加切片的长度到容量的大小。

要增加切片的容量必须创建一个新的，更大容量的切片，然后将原有的切片内容复制过去。整个技术是一些支持动态数组语言的常见实现。

- 先用make创建一个大容量的切片
- 然后使用循环或copy函数把原来的切片复制到目标切片
- copy(目标切片，原切片)；

如果需要完全的控制，我们可以自己构建添加函数。

但大部分程序不需要完全的控制，因此可以直接使用Go内置的函数`append`，用于大多数场合；它的函数签名为：

```go
func append(s [T], x ...T) []T
```

append函数将x追加到切片s的末尾，并且在必要到时候增加容量。

> 切片操作并不会复制底层的数组。整个数组将被保存在内存中，直到它不再被引用。
